# =============================================================================
# ConfigManager Module - Azure Local Load Tools
# =============================================================================
# Manages configuration pipeline: reads master-environment.yml, filters by
# solution tag, generates solution-specific JSON files, and provides the
# override chain for variable resolution.
# =============================================================================

#Requires -Modules powershell-yaml

# Module-level variables
$script:MasterConfig = $null
$script:SolutionConfigs = @{}
$script:ProjectRoot = (Resolve-Path (Join-Path $PSScriptRoot '..\..\..\..')).Path

function Import-MasterConfig {
    <#
    .SYNOPSIS
        Loads the master environment configuration from YAML.
    .DESCRIPTION
        Reads and parses the master-environment.yml file. Validates structure
        against expected schema. Caches the result for subsequent calls.
    .PARAMETER MasterConfigPath
        Path to master-environment.yml. Defaults to config/variables/master-environment.yml.
    .PARAMETER Force
        Force reload even if already cached.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$MasterConfigPath,

        [Parameter()]
        [switch]$Force
    )

    if (-not $MasterConfigPath) {
        $MasterConfigPath = Join-Path $script:ProjectRoot 'config\variables\master-environment.yml'
    }

    if ($script:MasterConfig -and -not $Force) {
        Write-Verbose "Master config already loaded. Use -Force to reload."
        return $script:MasterConfig
    }

    if (-not (Test-Path $MasterConfigPath)) {
        throw "Master environment file not found: $MasterConfigPath"
    }

    Write-Verbose "Loading master configuration from: $MasterConfigPath"
    $yamlContent = Get-Content -Path $MasterConfigPath -Raw
    $script:MasterConfig = ConvertFrom-Yaml $yamlContent

    # Validate basic structure
    if (-not $script:MasterConfig.metadata) {
        throw "Master config missing 'metadata' section"
    }
    if (-not $script:MasterConfig.variables) {
        throw "Master config missing 'variables' section"
    }

    Write-Verbose "Loaded $($script:MasterConfig.variables.Count) variables from master config v$($script:MasterConfig.metadata.version)"
    return $script:MasterConfig
}

function Export-SolutionConfig {
    <#
    .SYNOPSIS
        Generates a solution-specific JSON config from the master environment.
    .DESCRIPTION
        Filters variables from master-environment.yml by solution tag and writes
        a flat JSON file containing only the variables relevant to the specified solution.
    .PARAMETER Solution
        Solution name to filter for: vmfleet, fio, iperf, hammerdb, stress-ng.
    .PARAMETER MasterConfigPath
        Path to master-environment.yml.
    .PARAMETER OutputPath
        Output path for the generated JSON file.
    .PARAMETER ClusterConfigPath
        Optional cluster config to merge cluster-specific values.
    .EXAMPLE
        Export-SolutionConfig -Solution "vmfleet"
    .EXAMPLE
        Export-SolutionConfig -Solution "fio" -OutputPath ".\my-fio-config.json"
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [ValidateSet('vmfleet', 'fio', 'iperf', 'hammerdb', 'stress-ng')]
        [string]$Solution,

        [Parameter()]
        [string]$MasterConfigPath,

        [Parameter()]
        [string]$OutputPath,

        [Parameter()]
        [string]$ClusterConfigPath
    )

    # Load master config
    $masterConfig = Import-MasterConfig -MasterConfigPath $MasterConfigPath

    if (-not $OutputPath) {
        $OutputPath = Join-Path $script:ProjectRoot "config\variables\solutions\$Solution.json"
    }

    # Filter variables by solution tag
    $solutionVars = $masterConfig.variables | Where-Object {
        $_.solutions -contains $Solution
    }

    Write-Verbose "Found $($solutionVars.Count) variables tagged for solution: $Solution"

    # Build flat key-value object
    $configObject = [ordered]@{
        '_metadata' = [ordered]@{
            'solution'       = $Solution
            'generated_from' = 'config/variables/master-environment.yml'
            'generated_at'   = (Get-Date -Format 'o')
            'description'    = "$Solution-specific configuration (auto-generated by ConfigManager)"
        }
    }

    foreach ($var in $solutionVars) {
        # Skip sensitive variables â€” they should come from Key Vault at runtime
        if ($var.sensitive -eq $true) {
            $configObject[$var.name] = ''
        }
        else {
            $configObject[$var.name] = $var.value
        }
    }

    # Merge cluster config values if provided
    if ($ClusterConfigPath -and (Test-Path $ClusterConfigPath)) {
        Write-Verbose "Merging cluster config from: $ClusterConfigPath"
        $clusterYaml = Get-Content -Path $ClusterConfigPath -Raw
        $clusterConfig = ConvertFrom-Yaml $clusterYaml

        if ($clusterConfig.cluster) {
            $clusterMapping = @{
                'cluster_name'       = $clusterConfig.cluster.name
                'cluster_domain'     = $clusterConfig.cluster.domain
                'cluster_nodes'      = @($clusterConfig.cluster.nodes | ForEach-Object { $_.name })
                'csv_path'           = $clusterConfig.cluster.csv_path
                'collect_volume_path' = $clusterConfig.cluster.collect_volume_path
                'base_vhd_path'      = $clusterConfig.cluster.base_vhd_path
            }

            foreach ($key in $clusterMapping.Keys) {
                if ($configObject.Contains($key) -and $clusterMapping[$key]) {
                    $configObject[$key] = $clusterMapping[$key]
                }
            }
        }
    }

    # Ensure output directory exists
    $outputDir = Split-Path -Parent $OutputPath
    if (-not (Test-Path $outputDir)) {
        New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    }

    # Write JSON
    $jsonContent = $configObject | ConvertTo-Json -Depth 10
    Set-Content -Path $OutputPath -Value $jsonContent -Encoding UTF8

    Write-Verbose "Solution config written to: $OutputPath"

    # Cache the solution config
    $script:SolutionConfigs[$Solution] = $configObject

    return $OutputPath
}

function Get-ConfigValue {
    <#
    .SYNOPSIS
        Retrieves a configuration value with override chain support.
    .DESCRIPTION
        Resolves a variable value using the three-level override chain:
        1. Explicit override (highest priority)
        2. Solution JSON file
        3. Master environment default (lowest priority)
    .PARAMETER Name
        Variable name to retrieve (snake_case).
    .PARAMETER Solution
        Solution context for filtering (e.g., "vmfleet").
    .PARAMETER Override
        Explicit override value (highest priority in the chain).
    .PARAMETER DefaultValue
        Fallback if variable not found in any source.
    .PARAMETER SolutionConfigPath
        Path to the solution JSON file. Auto-resolved if not specified.
    .EXAMPLE
        Get-ConfigValue -Name "vm_count_per_node" -Solution "vmfleet"
    .EXAMPLE
        Get-ConfigValue -Name "vm_count_per_node" -Solution "vmfleet" -Override 20
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Name,

        [Parameter()]
        [string]$Solution,

        [Parameter()]
        $Override,

        [Parameter()]
        $DefaultValue,

        [Parameter()]
        [string]$SolutionConfigPath
    )

    # Level 1: Explicit override wins
    if ($PSBoundParameters.ContainsKey('Override') -and $null -ne $Override) {
        Write-Verbose "Config '$Name': using explicit override value"
        return $Override
    }

    # Level 2: Solution JSON
    if ($Solution) {
        if (-not $SolutionConfigPath) {
            $SolutionConfigPath = Join-Path $script:ProjectRoot "config\variables\solutions\$Solution.json"
        }

        if (Test-Path $SolutionConfigPath) {
            $solutionConfig = Get-Content -Path $SolutionConfigPath -Raw | ConvertFrom-Json -AsHashtable
            if ($solutionConfig.ContainsKey($Name) -and $solutionConfig[$Name] -ne '' -and $null -ne $solutionConfig[$Name]) {
                Write-Verbose "Config '$Name': using value from $Solution.json"
                return $solutionConfig[$Name]
            }
        }
    }

    # Level 3: Master environment default
    $masterConfig = Import-MasterConfig
    $variable = $masterConfig.variables | Where-Object { $_.name -eq $Name } | Select-Object -First 1

    if ($variable -and $null -ne $variable.value -and $variable.value -ne '') {
        Write-Verbose "Config '$Name': using master environment default"
        return $variable.value
    }

    # Fallback
    if ($PSBoundParameters.ContainsKey('DefaultValue')) {
        Write-Verbose "Config '$Name': using provided default value"
        return $DefaultValue
    }

    Write-Warning "Config '$Name': no value found in any source"
    return $null
}

function Test-MasterConfig {
    <#
    .SYNOPSIS
        Validates the master environment configuration.
    .DESCRIPTION
        Checks the master-environment.yml for structural correctness,
        required fields, and valid solution tags.
    .PARAMETER MasterConfigPath
        Path to master-environment.yml.
    .OUTPUTS
        PSCustomObject with IsValid (bool) and Errors (string[]) properties.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$MasterConfigPath
    )

    $errors = @()

    try {
        $config = Import-MasterConfig -MasterConfigPath $MasterConfigPath -Force
    }
    catch {
        return [PSCustomObject]@{
            IsValid = $false
            Errors  = @("Failed to load master config: $($_.Exception.Message)")
        }
    }

    $validSolutions = @('vmfleet', 'fio', 'iperf', 'hammerdb', 'stress-ng')
    $validTypes = @('string', 'integer', 'boolean', 'array')
    $namesSeen = @{}

    foreach ($var in $config.variables) {
        # Check required fields
        if (-not $var.name) { $errors += "Variable missing 'name' field" }
        if (-not $var.description) { $errors += "Variable '$($var.name)' missing 'description'" }
        if (-not $var.type) { $errors += "Variable '$($var.name)' missing 'type'" }
        if (-not $var.solutions -or $var.solutions.Count -eq 0) {
            $errors += "Variable '$($var.name)' has no solution tags"
        }

        # Check for duplicates
        if ($var.name -and $namesSeen.ContainsKey($var.name)) {
            $errors += "Duplicate variable name: '$($var.name)'"
        }
        $namesSeen[$var.name] = $true

        # Validate type
        if ($var.type -and $var.type -notin $validTypes) {
            $errors += "Variable '$($var.name)' has invalid type: '$($var.type)'"
        }

        # Validate solution tags
        if ($var.solutions) {
            foreach ($sol in $var.solutions) {
                if ($sol -notin $validSolutions) {
                    $errors += "Variable '$($var.name)' has invalid solution tag: '$sol'"
                }
            }
        }
    }

    return [PSCustomObject]@{
        IsValid = ($errors.Count -eq 0)
        Errors  = $errors
    }
}

function Export-AllSolutionConfigs {
    <#
    .SYNOPSIS
        Generates JSON config files for all solutions.
    .PARAMETER MasterConfigPath
        Path to master-environment.yml.
    .PARAMETER ClusterConfigPath
        Optional cluster config to merge.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$MasterConfigPath,

        [Parameter()]
        [string]$ClusterConfigPath
    )

    $solutions = @('vmfleet', 'fio', 'iperf', 'hammerdb', 'stress-ng')

    foreach ($solution in $solutions) {
        Write-Verbose "Generating config for: $solution"
        Export-SolutionConfig -Solution $solution -MasterConfigPath $MasterConfigPath -ClusterConfigPath $ClusterConfigPath
    }

    Write-Verbose "All solution configs generated successfully"
}

# Export module members
Export-ModuleMember -Function @(
    'Import-MasterConfig'
    'Export-SolutionConfig'
    'Export-AllSolutionConfigs'
    'Get-ConfigValue'
    'Test-MasterConfig'
)
